<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Motion GLB</title>
    <style>
        #seekbar-container:hover #seekbar-thumb {
            opacity: 1 !important;
            transform: translateY(-50%) scale(1.2) !important;
        }
        
        #seekbar-container:hover {
            height: 16px !important;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4) !important;
        }
        
        #seekbar-container:active {
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.5) !important;
        }
        
        #seekbar-container {
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        /* Play/Pause Button Styles */
        #play-pause-button {
            position: absolute;
            bottom: 20px;
            left: 30px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            vertical-align: middle;
        }

        #play-pause-button:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        }

        #play-pause-button:active {
            transform: scale(0.95);
        }

        /* Play/Pause Icons */
        .play-icon, .pause-icon {
            color: white;
            font-size: 16px;
            transition: all 0.2s ease;
        }

        .play-icon::before {
            content: '▶';
        }

        .pause-icon::before {
            content: '⏸';
        }

        /* Inline seekbar container */
        #seekbar-container {
            position: absolute; 
            bottom: 26px; /* Center align with 40px button */
            left: 85px; /* Start after the play button */
            right: 100px; /* Leave space for percentage */
            height: 12px; 
            background-color: rgba(255, 255, 255, 0.3); 
            border-radius: 6px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            transition: height 0.2s ease, box-shadow 0.2s ease;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            vertical-align: middle;
        }

        /* Progress percentage text */
        #progress-text-container {
            position: absolute; 
            bottom: 24px; /* Center align with button and seekbar */
            right: 30px; 
            color: white; 
            font-family: Arial, sans-serif; 
            font-size: 14px;
            opacity: 0.8;
            vertical-align: middle;
            line-height: 16px; /* Match seekbar height for perfect alignment */
        }
    </style>
</head>
<script>
    var model = null;
    const modelSwitchInterval = 1000 / 5;
    var currSnap = 1;
    var lastSnap = 1000;
    var isPlaying = true; // Track play/pause state

    // Global play/pause function accessible from HTML
    function togglePlayPause() {
        isPlaying = !isPlaying;
        const button = document.getElementById('play-pause-button');
        const icon = button.querySelector('.play-icon, .pause-icon');
        
        if (isPlaying) {
            icon.className = 'pause-icon';
            // Reset timer to avoid immediate frame switch when resuming
            if (window.lastModelSwitch !== undefined) {
                window.lastModelSwitch = Date.now();
            }
        } else {
            icon.className = 'play-icon';
        }
    }

    // Keyboard controls
    document.addEventListener('keydown', function(e) {
        if (e.code === 'Space') {
            e.preventDefault();
            togglePlayPause();
        }
    });
</script>

<script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/gh/mesquite-mocap/mesquite.cc/build-static/three.module.js';
    import { GLTFLoader } from 'https://cdn.jsdelivr.net/gh/mesquite-mocap/mesquite.cc/build-static/GLTFLoader.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/gh/mesquite-mocap/mesquite.cc/build-static/OrbitControls.js';
    import Stats from 'https://cdn.jsdelivr.net/gh/mesquite-mocap/mesquite.cc/build-static/stats.module.js';

    const stats = new Stats();
    stats.showPanel(0); // 0: fps, 1: ms, 2: memory
    document.body.appendChild(stats.dom);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);



    camera.position.z = 2.3;
    camera.position.y = 2.9;


    // controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; // an animation effect
    controls.dampingFactor = 0.25;
    controls.enableZoom = true;


    // Get current time for dynamic daylight
    function getTimeOfDay() {
        const now = new Date();
        const hours = now.getHours();
        const minutes = now.getMinutes();
        return hours + minutes / 60;
    }

    function getDaylightSettings() {
        const timeOfDay = getTimeOfDay();
        
        // Define lighting and background phases with reduced brightness
        if (timeOfDay >= 6 && timeOfDay < 8) {
            // Dawn (6-8 AM) - Darker
            return {
                skyTop: 0xcc6633,
                skyBottom: 0xb8860b,
                fogColor: 0xb8860b,
                sunColor: 0xffd700,
                ambientColor: 0xfff4e6,
                intensity: 0.8
            };
        } else if (timeOfDay >= 8 && timeOfDay < 12) {
            // Morning (8 AM - 12 PM) - Muted blue
            return {
                skyTop: 0x4682b4,
                skyBottom: 0x708090,
                fogColor: 0x708090,
                sunColor: 0xffffff,
                ambientColor: 0xf0f8ff,
                intensity: 1.2
            };
        } else if (timeOfDay >= 12 && timeOfDay < 17) {
            // Afternoon (12 PM - 5 PM) - Darker blue
            return {
                skyTop: 0x2e4b75,
                skyBottom: 0x4682b4,
                fogColor: 0x4682b4,
                sunColor: 0xffffff,
                ambientColor: 0xf0f8ff,
                intensity: 1.4
            };
        } else if (timeOfDay >= 17 && timeOfDay < 19) {
            // Evening (5-7 PM) - Muted sunset
            return {
                skyTop: 0xb8432a,
                skyBottom: 0xcd853f,
                fogColor: 0xcd853f,
                sunColor: 0xff8c42,
                ambientColor: 0xffe4cc,
                intensity: 1.0
            };
        } else if (timeOfDay >= 19 && timeOfDay < 21) {
            // Dusk (7-9 PM) - Darker twilight
            return {
                skyTop: 0x2e1065,
                skyBottom: 0xb22222,
                fogColor: 0x654321,
                sunColor: 0xff4500,
                ambientColor: 0xffd4a3,
                intensity: 0.6
            };
        } else {
            // Night (9 PM - 6 AM) - Very dark
            return {
                skyTop: 0x000022,
                skyBottom: 0x0f0f3a,
                fogColor: 0x0f0f3a,
                sunColor: 0x4169e1,
                ambientColor: 0x404040,
                intensity: 0.3
            };
        }
    }

    // Create dynamic sky background
    const skyGeometry = new THREE.SphereGeometry(200, 32, 32);
    const skyMaterial = new THREE.ShaderMaterial({
        uniforms: {
            topColor: { value: new THREE.Color(0x0077ff) },
            bottomColor: { value: new THREE.Color(0xffffff) },
            offset: { value: 15 },
            exponent: { value: 0.8 }
        },
        vertexShader: `
            varying vec3 vWorldPosition;
            void main() {
                vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                vWorldPosition = worldPosition.xyz;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            uniform vec3 topColor;
            uniform vec3 bottomColor;
            uniform float offset;
            uniform float exponent;
            varying vec3 vWorldPosition;
            void main() {
                float h = normalize(vWorldPosition + offset).y;
                gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
            }
        `,
        side: THREE.BackSide
    });
    
    const sky = new THREE.Mesh(skyGeometry, skyMaterial);
    scene.add(sky);

    // Add atmospheric fog with reduced visibility
    scene.fog = new THREE.Fog(0x4682b4, 30, 120);

    // Function to update background based on time of day
    function updateDaylightBackground() {
        const settings = getDaylightSettings();
        
        // Update sky colors with reduced intensity
        skyMaterial.uniforms.topColor.value.setHex(settings.skyTop);
        skyMaterial.uniforms.bottomColor.value.setHex(settings.skyBottom);
        
        // Update fog color and make it more dense for subtlety
        scene.fog.color.setHex(settings.fogColor);
        scene.fog.near = 25;
        scene.fog.far = settings.intensity > 1.0 ? 140 : 120;
        
        // Update scene background color with reduced brightness
        const bgColor = new THREE.Color(settings.skyBottom);
        bgColor.multiplyScalar(0.7); // Reduce background brightness by 30%
        scene.background = bgColor;
    }

    // Initialize daylight background
    updateDaylightBackground();

    // Soft warm ambient light for base illumination
    const ambientLight = new THREE.AmbientLight(0xfff4e6, 0.6); // Warm white ambient
    scene.add(ambientLight);

    // Main soft warm key light
    const keyLight = new THREE.DirectionalLight(0xfff0d4, 1.2); // Soft warm white
    keyLight.position.set(3, 8, 5);
    keyLight.castShadow = true;
    keyLight.shadow.mapSize.width = 2048;
    keyLight.shadow.mapSize.height = 2048;
    keyLight.shadow.camera.near = 0.5;
    keyLight.shadow.camera.far = 50;
    keyLight.shadow.camera.left = -15;
    keyLight.shadow.camera.right = 15;
    keyLight.shadow.camera.top = 15;
    keyLight.shadow.camera.bottom = -15;
    keyLight.shadow.bias = -0.0001;
    keyLight.shadow.radius = 10; // Soft shadows
    scene.add(keyLight);

    // Soft fill lights for even illumination
    const fillLight1 = new THREE.DirectionalLight(0xffe4cc, 0.8); // Warm peach
    fillLight1.position.set(-5, 5, 3);
    scene.add(fillLight1);

    const fillLight2 = new THREE.DirectionalLight(0xfff0d4, 0.6); // Warm white
    fillLight2.position.set(5, -3, 8);
    scene.add(fillLight2);

    const fillLight3 = new THREE.DirectionalLight(0xffedd5, 0.5); // Warm cream
    fillLight3.position.set(-3, 3, -5);
    scene.add(fillLight3);

    // Soft rim lights for definition
    const rimLight1 = new THREE.DirectionalLight(0xfff8dc, 0.4); // Very soft warm
    rimLight1.position.set(0, 8, -10);
    scene.add(rimLight1);

    const rimLight2 = new THREE.DirectionalLight(0xffefd5, 0.3); // Papaya whip
    rimLight2.position.set(-8, 2, -3);
    scene.add(rimLight2);

    // Bounced light from below for realistic fill
    const bounceLight = new THREE.DirectionalLight(0xfff0d4, 0.4);
    bounceLight.position.set(0, -8, 0);
    scene.add(bounceLight);

    // Additional hemisphere light for even softer fill
    const hemisphereLight = new THREE.HemisphereLight(0xfff4e6, 0xffe4cc, 0.5);
    hemisphereLight.position.set(0, 10, 0);
    scene.add(hemisphereLight);

    // Top spotlight for focused model illumination
    const topSpotlight = new THREE.SpotLight(0xffffff, 2.0); // Bright white spotlight
    topSpotlight.position.set(0, 115, 0); // Positioned directly above
    topSpotlight.target.position.set(0, 15, 0); // Targeting center of scene
    topSpotlight.angle = Math.PI / 6; // 30 degree cone
    topSpotlight.penumbra = 0.3; // Soft edge falloff
    topSpotlight.decay = 1; // Natural light falloff
    topSpotlight.distance = 30; // Light reaches 30 units
    topSpotlight.castShadow = true;
    
    // High quality shadow settings for the spotlight
    topSpotlight.shadow.mapSize.width = 1024;
    topSpotlight.shadow.mapSize.height = 1024;
    topSpotlight.shadow.camera.near = 0.5;
    topSpotlight.shadow.camera.far = 30;
    topSpotlight.shadow.focus = 1;
    topSpotlight.shadow.bias = -0.0002;
    
    scene.add(topSpotlight);
    scene.add(topSpotlight.target); // Add the target to the scene

    let lastModelSwitch = 0;
    window.lastModelSwitch = 0; // Make it globally accessible
    let lastBackgroundUpdate = 0;
    const backgroundUpdateInterval = 60000; // Update every minute

    function animate() {
        requestAnimationFrame(animate);
        
        const currentTime = Date.now();
        
        // Update daylight background every minute
        if (currentTime - lastBackgroundUpdate >= backgroundUpdateInterval) {
            updateDaylightBackground();
            lastBackgroundUpdate = currentTime;
        }
        
        // Switch models at specified interval (only if playing)
        if (isPlaying && currentTime - lastModelSwitch >= modelSwitchInterval) {
            var folder = String(currSnap).padStart(5, '0');
            var file = `../data/scripts/images/${folder}/output.glb`;
            loadModel(file);
            lastModelSwitch = currentTime;
            window.lastModelSwitch = currentTime; // Keep global sync
            
            // Update seekbar progress
            updateSeekbar();
            
            if(currSnap < lastSnap) {
                currSnap++;
            } else {
                currSnap = 1;
            }
        }
        
        controls.update();
        renderer.render(scene, camera);
    }

    // Start the animation loop
    animate();

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    window.addEventListener('resize', onWindowResize, false);

    function updateSeekbar() {
        const progress = (currSnap / lastSnap) * 100;
        const seekbarFill = document.getElementById('seekbar-fill');
        const seekbarThumb = document.getElementById('seekbar-thumb');
        const frameInfo = document.getElementById('info');
        const progressText = document.getElementById('progress-text');
        
        if (seekbarFill) {
            seekbarFill.style.width = progress + '%';
        }
        if (frameInfo) {
           // frameInfo.innerHTML = `<h1>${currSnap} / ${lastSnap}</h1>`;
        }
        if (progressText) {
            progressText.textContent = Math.round(progress) + '%';
        }
    }

    // Interactive seek functionality
    // Interactive seek functionality
    let isDragging = false;
    let wasPlaying = false;

    function seekToPosition(x) {
        const seekbarContainer = document.getElementById('seekbar-container');
        const rect = seekbarContainer.getBoundingClientRect();
        const percentage = Math.max(0, Math.min(1, (x - rect.left) / rect.width));
        const targetFrame = Math.round(percentage * lastSnap) || 1;
        
        currSnap = Math.max(1, Math.min(lastSnap, targetFrame));
        
        // Load the targeted frame immediately
        const folder = String(currSnap).padStart(5, '0');
        const file = `../data/scripts/images/${folder}/output.glb`;
        loadModel(file);
        
        // Update the seekbar display
        updateSeekbar();
    }

    // Add event listeners for interactive seeking
    document.addEventListener('DOMContentLoaded', function() {
        const seekbarContainer = document.getElementById('seekbar-container');
        
        if (seekbarContainer) {
            // Mouse events
            seekbarContainer.addEventListener('mousedown', function(e) {
                isDragging = true;
                wasPlaying = isPlaying;
                isPlaying = false; // Pause during seek
                seekToPosition(e.clientX);
                e.preventDefault();
            });

            document.addEventListener('mousemove', function(e) {
                if (isDragging) {
                    seekToPosition(e.clientX);
                    e.preventDefault();
                }
            });

            document.addEventListener('mouseup', function() {
                if (isDragging) {
                    isDragging = false;
                    isPlaying = wasPlaying; // Resume previous play state
                    if (isPlaying) {
                        lastModelSwitch = Date.now();
                    }
                    // Update button appearance
                    const button = document.getElementById('play-pause-button');
                    const icon = button.querySelector('.play-icon, .pause-icon');
                    if (icon) {
                        icon.className = isPlaying ? 'pause-icon' : 'play-icon';
                    }
                }
            });

            // Touch events for mobile
            seekbarContainer.addEventListener('touchstart', function(e) {
                isDragging = true;
                wasPlaying = true;
                const touch = e.touches[0];
                seekToPosition(touch.clientX);
                e.preventDefault();
            });

            document.addEventListener('touchmove', function(e) {
                if (isDragging) {
                    const touch = e.touches[0];
                    seekToPosition(touch.clientX);
                    e.preventDefault();
                }
            });

            document.addEventListener('touchend', function() {
                if (isDragging) {
                    isDragging = false;
                    lastModelSwitch = Date.now();
                }
            });

            // Click to seek
            seekbarContainer.addEventListener('click', function(e) {
                if (!isDragging) {
                    seekToPosition(e.clientX);
                    lastModelSwitch = Date.now();
                }
            });
        }
    });

    function loadModel(url) {
        const loader = new GLTFLoader();
        loader.load(url, function (gltf) {
            const newModel = gltf.scene;
            newModel.scale.set(4, 4, 4);
            newModel.position.set(0, -.7, 0);
            
            if (model) {
                // Add new model to scene
                scene.add(newModel);
                
                // Make new model initially transparent
                newModel.traverse((child) => {
                    if (child.isMesh) {
                        child.material = child.material.clone();
                        child.material.transparent = true;
                        child.material.opacity = 0;
                    }
                });
                
                // Start cinematic morphing animation
                cinematicMorph(model, newModel, () => {
                    // Callback when morphing is complete
                    scene.remove(model);
                    model = newModel;
                });
                
                stats.update();
            } else {
                // First model load
                scene.add(newModel);
                model = newModel;
                stats.begin();
                updateSeekbar();
            }
        }, undefined, function (error) {
            console.error(error);
        });
    }

    function cinematicMorph(fromModel, toModel, onComplete) {
        const morphDuration = modelSwitchInterval * .1; // Slightly longer for cinematic effect
        const startTime = Date.now();
        
        function animateMorph() {
            const elapsed = Date.now() - startTime;
            const progress = Math.min(elapsed / morphDuration, 1);
            
            // Cinematic easing with more dramatic curve
            const easedProgress = progress < 0.5 
                ? 2 * progress * progress * progress  // Ease in (cubic)
                : 1 - Math.pow(-2 * progress + 2, 3) / 2; // Ease out (cubic)
            
            // Cinematic fade with slight overlap for smoother transition
            const fadeOutStart = 0;
            const fadeOutEnd = 0.7;
            const fadeInStart = 0.3;
            const fadeInEnd = 1;
            
            // Calculate fade values with overlap
            let fadeOut = 1;
            let fadeIn = 0;
            
            if (progress >= fadeOutStart && progress <= fadeOutEnd) {
                const fadeOutProgress = (progress - fadeOutStart) / (fadeOutEnd - fadeOutStart);
                fadeOut = 1 - (fadeOutProgress * fadeOutProgress); // Quadratic fade out
            } else if (progress > fadeOutEnd) {
                fadeOut = 0;
            }
            
            if (progress >= fadeInStart && progress <= fadeInEnd) {
                const fadeInProgress = (progress - fadeInStart) / (fadeInEnd - fadeInStart);
                fadeIn = fadeInProgress * fadeInProgress; // Quadratic fade in
            }
            
            // Apply fading to old model
            fromModel.traverse((child) => {
                if (child.isMesh) {
                    if (!child.material.transparent) {
                        child.material = child.material.clone();
                        child.material.transparent = true;
                    }
                    child.material.opacity = fadeOut;
                }
            });
            
            // Apply fading to new model
            toModel.traverse((child) => {
                if (child.isMesh) {
                    child.material.opacity = fadeIn;
                }
            });
            
            // Subtle cinematic lighting variation
            const lightIntensity = 1 + (Math.sin(easedProgress * Math.PI * 2) * 0.1);
            if (keyLight) keyLight.intensity = 1.2 * lightIntensity;
            
            if (progress >= 1) {
                // Reset lighting to normal
                if (keyLight) keyLight.intensity = 1.2;
                // Morphing complete
                onComplete();
            } else {
                // Continue morphing
                requestAnimationFrame(animateMorph);
            }
        }
        
        // Start the cinematic morphing animation
        animateMorph();
    }
</script>

<body style="margin: 0; overflow: hidden; background-color: black;">
    <div id="info" style="color: white; position: absolute; bottom: 70px; left: 30px; padding: 10px;"></div>
    
    <!-- Play/Pause Button -->
    <button id="play-pause-button" onclick="togglePlayPause()">
        <span class="pause-icon"></span>
    </button>
    
    <!-- Interactive Seekbar -->
    <div id="seekbar-container">
        <div id="seekbar-fill" style="
            height: 100%; 
            background: linear-gradient(90deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #ffeaa7);
            border-radius: 6px;
            width: 0%; 
            transition: width 0.1s ease-out;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.4);
            position: relative;
        ">
            <!-- Seek handle/thumb -->
            <div id="seekbar-thumb" style="
                position: absolute;
                right: -6px;
                top: 50%;
                transform: translateY(-50%);
                width: 12px;
                height: 12px;
                background: white;
                border-radius: 50%;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
                opacity: 0;
                transition: opacity 0.2s ease, transform 0.2s ease;
            "></div>
        </div>
    </div>
    
    <!-- Progress text -->
    <div id="progress-text-container">
        <span id="progress-text">0%</span>
    </div>
</body>

</html>