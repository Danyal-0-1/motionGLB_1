<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Motion GLB</title>

    <script>
    var model = null;
    const modelSwitchInterval = 1000 / 20;
    var firstSnap = 1;
    var currSnap = firstSnap;
    var lastSnap = 5257;
    var isPlaying = true; // Track play/pause state

    // Global play/pause function accessible from HTML
    function togglePlayPause() {
        isPlaying = !isPlaying;
        const button = document.getElementById('play-pause-button');
        const icon = button.querySelector('.play-icon, .pause-icon');
         
        if (isPlaying) {
            icon.className = 'pause-icon';
            // Reset timer to avoid immediate frame switch when resuming
            if (window.lastModelSwitch !== undefined) {
                window.lastModelSwitch = Date.now();
            }
        } else {
            icon.className = 'play-icon';
        }
    }

    // Keyboard controls
    document.addEventListener('keydown', function(e) {
        if (e.code === 'Space') {
            e.preventDefault();
            togglePlayPause();
        }
    });
</script>

    <style>

        a{
            display: none!important;
        }
        #VRButton{
            position: fixed !important;
            top: 0px !important;
            right: 0px !important;
            max-height: 60px !important;
            z-index: 1000 !important;
            border-radius: 8px !important;
            background: rgba(0, 0, 0, 0.8) !important;
            color: white !important;
            border: 2px solid #667eea !important;
            padding: 10px 15px !important;
            font-size: 14px !important;
            font-family: Arial, sans-serif !important;
            cursor: pointer !important;
            transition: all 0.3s ease !important;
            margin-left: auto !important;
        }
        
        #VRButton:hover {
            background: rgba(102, 126, 234, 0.9) !important;
            transform: scale(1.05) !important;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.5) !important;
        }
        #seekbar-container:hover #seekbar-thumb {
            opacity: 1 !important;
            transform: translateY(-50%) scale(1.2) !important;
        }
        
        #seekbar-container:hover {
            height: 16px !important;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4) !important;
        }
        
        #seekbar-container:active {
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.5) !important;
        }
        
        #seekbar-container {
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        /* Play/Pause Button Styles */
        #play-pause-button {
            position: absolute;
            bottom: 20px;
            left: 30px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            vertical-align: middle;
        }

        #play-pause-button:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        }

        #play-pause-button:active {
            transform: scale(0.95);
        }

        /* Play/Pause Icons */
        .play-icon, .pause-icon {
            color: white;
            background-color: transparent;
            font-size: 16px;
            transition: all 0.2s ease;
        }

        .play-icon::before {
            content: '▶';
        }

        .pause-icon::before {
            content: '⏸';
        }

        /* Inline seekbar container */
        #seekbar-container {
            position: absolute; 
            bottom: 34px; /* Center align with 40px button */
            left: 85px; /* Start after the play button */
            right: 100px; /* Leave space for percentage */
            height: 12px; 
            background-color: rgba(255, 255, 255, 0.3); 
            border-radius: 6px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            cursor: pointer;
            transition: height 0.2s ease, box-shadow 0.2s ease;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            vertical-align: middle;
        }

        /* Progress percentage text */
        #progress-text-container {
            position: absolute; 
            bottom: 24px; /* Center align with button and seekbar */
            right: 10px; 
            color: white; 
            font-family: Arial, sans-serif; 
            font-size: 14px;
            opacity: 0.8;
            vertical-align: middle;
            text-align: center;
            line-height: 16px; /* Match seekbar height for perfect alignment */
        }
    </style>
</head>


<script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/gh/mesquite-mocap/mesquite.cc/build-static/three.module.js';
    import { GLTFLoader } from 'https://cdn.jsdelivr.net/gh/mesquite-mocap/mesquite.cc/build-static/GLTFLoader.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/gh/mesquite-mocap/mesquite.cc/build-static/OrbitControls.js';
    import { VRButton } from 'https://cdn.jsdelivr.net/gh/mesquite-mocap/mesquite.cc/build-static/VRButton.js';
    import Stats from 'https://cdn.jsdelivr.net/gh/mesquite-mocap/mesquite.cc/build-static/stats.module.js';

    const stats = new Stats();
    stats.showPanel(0); // 0: fps, 1: ms, 2: memory
    document.body.appendChild(stats.dom);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    
    // Enable clipping planes and shadows
    renderer.localClippingEnabled = true;
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    
    // Enable XR support for VR
    renderer.xr.enabled = true;
    
    // Configure VR camera to be in front of model at eye level
    renderer.xr.addEventListener('sessionstart', () => {
        // Position VR user in front of the model at comfortable viewing distance
        // Model is at y = -0.7, so position user at eye level (y = 0) looking down slightly
        const vrCameraGroup = new THREE.Group();
        vrCameraGroup.position.set(0, 0, 3); // 3 units in front of model
        vrCameraGroup.lookAt(0, -0.5, 0); // Look slightly down at the model center
        
        // Create reference space offset to position user correctly
        const offsetPosition = { x: 0, y: 0, z: -3 }; // User positioned 3 units back from origin
        const offsetRotation = { x: 0, y: 0, z: 0, w: 1 }; // No initial rotation
        
        try {
            const transform = new XRRigidTransform(offsetPosition, offsetRotation);
            renderer.xr.getReferenceSpace().then((referenceSpace) => {
                const offsetReferenceSpace = referenceSpace.getOffsetReferenceSpace(transform);
                renderer.xr.setReferenceSpace(offsetReferenceSpace);
            }).catch((error) => {
                console.warn('Could not set VR reference space:', error);
            });
        } catch (error) {
            console.warn('XRRigidTransform not available:', error);
        }
    });
    
    // Create clipping plane to hide bottom 20% of model
    // The model is positioned at y = -0.7 and scaled by 4
    // So we need to clip at approximately y = -0.7 - (model_height * 0.2)
    // Assuming model height is about 2 units when scaled, we clip at y = -1.3
    const clippingPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 1.12);
    
    document.body.appendChild(renderer.domElement);
    
    // Add VR button in top right corner
    const vrButton = VRButton.createButton(renderer);
    vrButton.style.position = 'absolute';
    vrButton.style.top = '20px';
    vrButton.style.right = '20px';
    vrButton.style.zIndex = '1000';
    vrButton.style.borderRadius = '8px';
    vrButton.style.background = 'rgba(0, 0, 0, 0.8)';
    vrButton.style.color = 'white';
    vrButton.style.border = '2px solid #667eea';
    vrButton.style.padding = '10px 15px';
    vrButton.style.fontSize = '14px';
    vrButton.style.fontFamily = 'Arial, sans-serif';
    vrButton.style.cursor = 'pointer';
    vrButton.style.transition = 'all 0.3s ease';
    document.body.appendChild(vrButton);



   // camera.position.z = 2.3;
   // camera.position.y = 2.9;


    // controls
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true; // an animation effect
    controls.dampingFactor = 0.25;
    controls.enableZoom = true;


    // Get current time for dynamic daylight
    function getTimeOfDay() {
        const now = new Date();
        const hours = now.getHours();
        const minutes = now.getMinutes();
        return hours + minutes / 60;
    }

    function getDaylightSettings() {
        const timeOfDay = getTimeOfDay();
        
        // Define lighting and background phases with reduced brightness
        if (timeOfDay >= 6 && timeOfDay < 8) {
            // Dawn (6-8 AM) - Darker
            return {
                skyTop: 0xcc6633,
                skyBottom: 0xb8860b,
                fogColor: 0xb8860b,
                sunColor: 0xffd700,
                ambientColor: 0xfff4e6,
                intensity: 0.8
            };
        } else if (timeOfDay >= 8 && timeOfDay < 12) {
            // Morning (8 AM - 12 PM) - Muted blue
            return {
                skyTop: 0x4682b4,
                skyBottom: 0x708090,
                fogColor: 0x708090,
                sunColor: 0xffffff,
                ambientColor: 0xf0f8ff,
                intensity: 1.2
            };
        } else if (timeOfDay >= 12 && timeOfDay < 17) {
            // Afternoon (12 PM - 5 PM) - Darker blue
            return {
                skyTop: 0x2e4b75,
                skyBottom: 0x4682b4,
                fogColor: 0x4682b4,
                sunColor: 0xffffff,
                ambientColor: 0xf0f8ff,
                intensity: 1.4
            };
        } else if (timeOfDay >= 17 && timeOfDay < 19) {
            // Evening (5-7 PM) - Muted sunset
            return {
                skyTop: 0xb8432a,
                skyBottom: 0xcd853f,
                fogColor: 0xcd853f,
                sunColor: 0xff8c42,
                ambientColor: 0xffe4cc,
                intensity: 1.0
            };
        } else if (timeOfDay >= 19 && timeOfDay < 21) {
            // Dusk (7-9 PM) - Darker twilight
            return {
                skyTop: 0x2e1065,
                skyBottom: 0xb22222,
                fogColor: 0x654321,
                sunColor: 0xff4500,
                ambientColor: 0xffd4a3,
                intensity: 0.6
            };
        } else {
            // Night (9 PM - 6 AM) - Very dark
            return {
                skyTop: 0x000022,
                skyBottom: 0x0f0f3a,
                fogColor: 0x0f0f3a,
                sunColor: 0x4169e1,
                ambientColor: 0x404040,
                intensity: 0.3
            };
        }
    }

    // Create dynamic sky background
    const skyGeometry = new THREE.SphereGeometry(200, 32, 32);
    const skyMaterial = new THREE.ShaderMaterial({
        uniforms: {
            topColor: { value: new THREE.Color(0x0077ff) },
            bottomColor: { value: new THREE.Color(0xffffff) },
            offset: { value: 15 },
            exponent: { value: 0.8 }
        },
        vertexShader: `
            varying vec3 vWorldPosition;
            void main() {
                vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                vWorldPosition = worldPosition.xyz;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
        fragmentShader: `
            uniform vec3 topColor;
            uniform vec3 bottomColor;
            uniform float offset;
            uniform float exponent;
            varying vec3 vWorldPosition;
            void main() {
                float h = normalize(vWorldPosition + offset).y;
                gl_FragColor = vec4(mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0)), 1.0);
            }
        `,
        side: THREE.BackSide
    });
    
    const sky = new THREE.Mesh(skyGeometry, skyMaterial);
    scene.add(sky);

    // Add atmospheric fog with reduced visibility
    scene.fog = new THREE.Fog(0x4682b4, 30, 120);

    // Function to update background based on time of day
    function updateDaylightBackground() {
        const settings = getDaylightSettings();
        
        // Update sky colors with reduced intensity
        skyMaterial.uniforms.topColor.value.setHex(settings.skyTop);
        skyMaterial.uniforms.bottomColor.value.setHex(settings.skyBottom);
        
        // Update fog color and make it more dense for subtlety
        scene.fog.color.setHex(settings.fogColor);
        scene.fog.near = 25;
        scene.fog.far = settings.intensity > 1.0 ? 140 : 120;
        
        // Update scene background color with reduced brightness
        const bgColor = new THREE.Color(settings.skyBottom);
        bgColor.multiplyScalar(0.7); // Reduce background brightness by 30%
        scene.background = bgColor;
    }

    // Initialize daylight background
    updateDaylightBackground();

    // Soft warm ambient light for base illumination
    const ambientLight = new THREE.AmbientLight(0xfff4e6, 0.6); // Warm white ambient
    scene.add(ambientLight);

    // Main soft warm key light
    const keyLight = new THREE.DirectionalLight(0xfff0d4, 1.2); // Soft warm white
    keyLight.position.set(3, 8, 5);
    keyLight.castShadow = true;
    keyLight.shadow.mapSize.width = 2048;
    keyLight.shadow.mapSize.height = 2048;
    keyLight.shadow.camera.near = 0.5;
    keyLight.shadow.camera.far = 50;
    keyLight.shadow.camera.left = -15;
    keyLight.shadow.camera.right = 15;
    keyLight.shadow.camera.top = 15;
    keyLight.shadow.camera.bottom = -15;
    keyLight.shadow.bias = -0.0001;
    keyLight.shadow.radius = 10; // Soft shadows
    scene.add(keyLight);

    // Soft fill lights for even illumination
    const fillLight1 = new THREE.DirectionalLight(0xffe4cc, 0.8); // Warm peach
    fillLight1.position.set(-5, 5, 3);
    scene.add(fillLight1);

    const fillLight2 = new THREE.DirectionalLight(0xfff0d4, 0.6); // Warm white
    fillLight2.position.set(5, -3, 8);
    scene.add(fillLight2);

    const fillLight3 = new THREE.DirectionalLight(0xffedd5, 0.5); // Warm cream
    fillLight3.position.set(-3, 3, -5);
    scene.add(fillLight3);

    // Soft rim lights for definition
    const rimLight1 = new THREE.DirectionalLight(0xfff8dc, 0.4); // Very soft warm
    rimLight1.position.set(0, 8, -10);
    scene.add(rimLight1);

    const rimLight2 = new THREE.DirectionalLight(0xffefd5, 0.3); // Papaya whip
    rimLight2.position.set(-8, 2, -3);
    scene.add(rimLight2);

    // Bounced light from below for realistic fill
    const bounceLight = new THREE.DirectionalLight(0xfff0d4, 0.4);
    bounceLight.position.set(0, -8, 0);
    scene.add(bounceLight);

    // Additional hemisphere light for even softer fill
    const hemisphereLight = new THREE.HemisphereLight(0xfff4e6, 0xffe4cc, 0.5);
    hemisphereLight.position.set(0, 10, 0);
    scene.add(hemisphereLight);

    // Top spotlight for focused model illumination
    const topSpotlight = new THREE.SpotLight(0xffffff, 2.0); // Bright white spotlight
    topSpotlight.position.set(0, 115, 0); // Positioned directly above
    topSpotlight.target.position.set(0, 15, 0); // Targeting center of scene
    topSpotlight.angle = Math.PI / 6; // 30 degree cone
    topSpotlight.penumbra = 0.3; // Soft edge falloff
    topSpotlight.decay = 1; // Natural light falloff
    topSpotlight.distance = 30; // Light reaches 30 units
    topSpotlight.castShadow = true;
    
    // High quality shadow settings for the spotlight
    topSpotlight.shadow.mapSize.width = 1024;
    topSpotlight.shadow.mapSize.height = 1024;
    topSpotlight.shadow.camera.near = 0.5;
    topSpotlight.shadow.camera.far = 30;
    topSpotlight.shadow.focus = 1;
    topSpotlight.shadow.bias = -0.0002;
    
    scene.add(topSpotlight);
    scene.add(topSpotlight.target); // Add the target to the scene

    let lastModelSwitch = 0;
    window.lastModelSwitch = 0; // Make it globally accessible
    let lastBackgroundUpdate = 0;
    const backgroundUpdateInterval = 60000; // Update every minute

    function animate() {
        const currentTime = Date.now();
        
        // Update daylight background every minute
        if (currentTime - lastBackgroundUpdate >= backgroundUpdateInterval) {
            updateDaylightBackground();
            lastBackgroundUpdate = currentTime;
        }
        
        // Switch models at specified interval (only if playing)
        if (isPlaying && currentTime - lastModelSwitch >= modelSwitchInterval) {
            var folder = String(currSnap - firstSnap).padStart(5, '0');
            //var file = `./images/${folder}/output.glb`;
            var file = `https://cdn.jsdelivr.net/gh/tejaswigowda/motionGLB/data/scripts/images/${folder}/output.glb`;
            loadModel(file);
            lastModelSwitch = currentTime;
            window.lastModelSwitch = currentTime; // Keep global sync
            
            // Update seekbar progress
            updateSeekbar();
            
            if(currSnap < lastSnap) {
                currSnap++;
            } else {
                // Stop playing when reaching the end and reset to beginning
                isPlaying = false;
                currSnap = firstSnap;
                const button = document.getElementById('play-pause-button');
                const icon = button.querySelector('.play-icon, .pause-icon');
                if (icon) {
                    icon.className = 'play-icon';
                }
                // Update seekbar to reflect reset position
                updateSeekbar();
            }
        }
        
        controls.update();
        renderer.render(scene, camera);
    }

    // Use XR-compatible animation loop
    renderer.setAnimationLoop(animate);

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }
    window.addEventListener('resize', onWindowResize, false);

    function updateSeekbar() {
        const progress = (currSnap / lastSnap) * 100;
        const seekbarFill = document.getElementById('seekbar-fill');
        const seekbarThumb = document.getElementById('seekbar-thumb');
        const frameInfo = document.getElementById('info');
        const progressText = document.getElementById('progress-text');

        if (seekbarFill) {
            seekbarFill.style.width = " " + progress + '%';
        }
        if (frameInfo) {
           // frameInfo.innerHTML = `<h1>${currSnap} / ${lastSnap}</h1>`;
        }
        if (progressText) {
            var x = lastSnap - firstSnap + 1;
            progressText.innerHTML = `${currSnap} / ${x} <br> <p style="text-align: center; margin:0px">(${Math.round(progress)}%)</p>`;
        }
    }

    // Interactive seek functionality
    // Interactive seek functionality
    let isDragging = false;
    let wasPlaying = false;

    function seekToPosition(x) {
        const seekbarContainer = document.getElementById('seekbar-container');
        const rect = seekbarContainer.getBoundingClientRect();
        const percentage = Math.max(0, Math.min(1, (x - rect.left) / rect.width));
        const targetFrame = Math.round(percentage * lastSnap) || 1;
        
        currSnap = Math.max(1, Math.min(lastSnap, targetFrame));
        
        // Load the targeted frame immediately
        const folder = String(currSnap).padStart(5, '0');
        const file = `../data/scripts/images/${folder}/output.glb`;
        loadModel(file);
        
        // Update the seekbar display
        updateSeekbar();
    }

    // Add event listeners for interactive seeking
    document.addEventListener('DOMContentLoaded', function() {
        const seekbarContainer = document.getElementById('seekbar-container');
        
        if (seekbarContainer) {
            // Mouse events
            seekbarContainer.addEventListener('mousedown', function(e) {
                isDragging = true;
                wasPlaying = isPlaying;
                isPlaying = false; // Pause during seek
                seekToPosition(e.clientX);
                e.preventDefault();
            });

            document.addEventListener('mousemove', function(e) {
                if (isDragging) {
                    seekToPosition(e.clientX);
                    e.preventDefault();
                }
            });

            document.addEventListener('mouseup', function() {
                if (isDragging) {
                    isDragging = false;
                    isPlaying = wasPlaying; // Resume previous play state
                    if (isPlaying) {
                        lastModelSwitch = Date.now();
                    }
                    // Update button appearance
                    const button = document.getElementById('play-pause-button');
                    const icon = button.querySelector('.play-icon, .pause-icon');
                    if (icon) {
                        icon.className = isPlaying ? 'pause-icon' : 'play-icon';
                    }
                }
            });

            // Touch events for mobile
            seekbarContainer.addEventListener('touchstart', function(e) {
                isDragging = true;
                wasPlaying = true;
                const touch = e.touches[0];
                seekToPosition(touch.clientX);
                e.preventDefault();
            });

            document.addEventListener('touchmove', function(e) {
                if (isDragging) {
                    const touch = e.touches[0];
                    seekToPosition(touch.clientX);
                    e.preventDefault();
                }
            });

            document.addEventListener('touchend', function() {
                if (isDragging) {
                    isDragging = false;
                    lastModelSwitch = Date.now();
                }
            });

            // Click to seek
            seekbarContainer.addEventListener('click', function(e) {
                if (!isDragging) {
                    seekToPosition(e.clientX);
                    lastModelSwitch = Date.now();
                }
            });
        }
    });

    function loadModel(url) {
        const loader = new GLTFLoader();
        loader.load(url, function (gltf) {
            const newModel = gltf.scene;
            newModel.scale.set(4, 4, 4);
            newModel.position.set(0, 0, -5);
            
            // Apply clipping plane to all materials
            newModel.traverse((child) => {
                if (child.isMesh) {
                    child.material = child.material.clone();
                    child.material.clippingPlanes = [clippingPlane];
                    child.material.side = THREE.DoubleSide;
                }
            });
            
            scene.add(newModel);
            
            if (model) {
                function y(m) {
                    setTimeout(() => {
                        scene.remove(m);
                    }, modelSwitchInterval / 1);
                }
                y(model);
                stats.update();
            } else {
                stats.begin();
                // Initialize seekbar on first load
                updateSeekbar();
            }
            model = newModel;
        }, undefined, function (error) {
            console.error(error);
        });
    }
</script>

<body style="margin: 0; overflow: hidden; background-color: black;">
    <div id="info" style="color: white; position: absolute; bottom: 70px; left: 30px; padding: 10px;"></div>
    
    <!-- Play/Pause Button -->
    <button id="play-pause-button" onclick="togglePlayPause()">
        <span class="pause-icon"></span>
    </button>
    
    <!-- Interactive Seekbar -->
    <div id="seekbar-container">
        <div id="seekbar-fill" style="
            height: 100%; 
            background: linear-gradient(90deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #ffeaa7);
            border-radius: 6px;
            width: 0%; 
            transition: width 0.1s ease-out;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.4);
            position: relative;
        ">
            <!-- Seek handle/thumb -->
            <div id="seekbar-thumb" style="
                position: absolute;
                right: -6px;
                top: 50%;
                transform: translateY(-50%);
                width: 12px;
                height: 12px;
                background: white;
                border-radius: 50%;
                box-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
                opacity: 0;
                transition: opacity 0.2s ease, transform 0.2s ease;
            "></div>
        </div>
    </div>
    
    <!-- Progress text -->
    <div style="
        position: absolute; 
        bottom: 25px; 
        right: 10px; 
        color: white; 
        font-family: Arial, sans-serif; 
        font-size: 14px;
        opacity: 0.8;
    ">
        <span id="progress-text" style="white-space: nowrap;text-align: center;">0%</span>
    </div>
</body>

</html>
